<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NHL Nationality</title>
<link href="https://fonts.googleapis.com/css2?family=Abril+Fatface&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<style>
  :root { --bg:#0b0e13; --panel:#121622; --ink:#e8ecf1; --muted:#aab3c2; --accent:#6aa6ff; --grid:#2a3245; --gridBright:#3b4661; }
  body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:var(--bg); color:var(--ink); }

  /* Brand header (like Simpsons post) */
  .site-header {
    position: sticky; top: 0; z-index: 5;
    display:flex; align-items:center; gap:12px;
    padding:10px 16px; border-bottom:1px solid rgba(255,255,255,.08);
    background: rgba(11,14,19,0.9); -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
  }
  .brand a {
    text-decoration:none; color:#fff; font-weight:600; letter-spacing:.2px;
    font-family: 'Abril Fatface', serif; font-size:20px; line-height:1;
  }
  .brand a:hover { opacity:.8; }
  .divider { width:1px; height:18px; background: rgba(255,255,255,.12); }

  .wrap { max-width:1100px; margin: 20px auto 48px; padding: 0 16px; }
  h1 { font-size:24px; margin:0 0 4px; }
  .sub { color:var(--muted); margin-bottom:16px; font-size:14px; }
  .chart-card { background:var(--panel); border-radius:18px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.3); }
  .controls { margin-bottom:10px; display:flex; gap:10px; align-items:center;}
  .controls label { font-size:12px; color:var(--muted); }
  .controls input { background:#0e1526; color:var(--ink); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:6px 8px; font-size:13px; width:120px; }
  .chart { width:100%; height:640px; position:relative; }
  .axis path, .axis line { stroke:var(--grid); }
  .axis text { fill:var(--muted); font-size:12px; }
  .areas .area { opacity:.95; transition:opacity .15s; }
  .areas .area.dim { opacity:.18; filter:grayscale(30%); }
  .legend { display:grid; grid-template-columns:repeat(auto-fill,minmax(200px,1fr)); gap:8px 10px; margin-top:14px; }
  .legend .item { display:flex; align-items:center; gap:10px; padding:8px 12px; border-radius:12px; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.08); cursor:pointer; }
  .legend .item.active { outline:2px solid var(--accent); background:rgba(106,166,255,.12); }
  .legend .flag { font-size:18px; }
  .legend .name { flex:1; font-size:13px; }
  .legend .val { font-size:12px; color:var(--muted); font-variant-numeric:tabular-nums; }
  .tooltip { position:absolute; pointer-events:none; z-index:10; background:#0d1220; color:var(--ink); border:1px solid rgba(255,255,255,.1); padding:8px 10px; border-radius:10px; font-size:12px; box-shadow:0 6px 18px rgba(0,0,0,.35); opacity:0; }
  .year-marker line { stroke:var(--gridBright); stroke-width:1.25; }
  .year-badge { fill:#0d1220; stroke:rgba(255,255,255,.15); stroke-width:1; }
  .year-text { fill:var(--ink); font-size:11px; }
  .grid-top line { stroke:var(--gridBright); stroke-dasharray:2 3; }
  .lockout-bar { fill:#000; }
  .lockout-text { fill:#fff; font-weight:700; font-size:11px; }
  .toplabel { fill:var(--ink); font-size:12px; stroke:rgba(0,0,0,.35); stroke-width:2px; paint-order:stroke; }
  .era-band { fill:rgba(255,255,255,0.06); stroke:rgba(255,255,255,0.12); cursor:pointer; }
  .era-label { fill:#e6ebf5; font-size:11px; font-weight:600; pointer-events:none; }
  .event-band { fill:rgba(255,255,255,0.06); stroke:rgba(255,255,255,0.12); }
  .event-line { stroke:rgba(255,255,255,0.7); stroke-width:1.25; }
  .event-label { fill:#cfd6e6; font-size:11px; }
  @media (max-width: 720px){
    .hide-mobile { display:none !important; }
  }
</style>
</head>
<body>

<!-- Brand header -->
<header class="site-header">
  <div class="brand"><a href="../index.html" title="Ari Winkleman">Ari Winkleman</a></div>
  <div class="divider" aria-hidden="true"></div>
  <div style="color:#cfd6e6; font-size:13px;">NHL Nationality</div>
</header>

<div class="wrap">
  <h1>NHL Games by Player Nationality (Share by Year)</h1>
  <div class="sub">Source: <a href="https://www.quanthockey.com/nhl/nationality-totals/nhl-players-career-stats.html" target="_blank" style="color:#6aa6ff">Quant Hockey</a>. Data download: <a href="2025_NHL_Nationality.csv" target="_blank" style="color:#6aa6ff">CSV</a></div>
  <div class="chart-card">
    <div class="controls">
      <label for="yearSearch">Go to year:</label>
      <input id="yearSearch" type="number" placeholder="e.g. 2005" />
    </div>
    <div id="chart" class="chart"></div>
    <div id="legend" class="legend"></div>
  </div>
</div>

<script>
/* ---------- Config ---------- */
const LOCKOUT_YEAR = 2005;
const ERA_BANDS_FULL = [
  {start:1917,end:1942,label:"Founding (1917â€“1942)"},
  {start:1942,end:1967,label:"Original Six era (1942â€“1967)"},
  {start:1967,end:1992,label:"Expansion era (1967â€“1992)"},
  {start:1992,end:2025,label:"Modern era (1992â€“2025)"}
];
const ERA_BANDS_SHORT = [
  {start:1917,end:1942,label:"Founding"},
  {start:1942,end:1967,label:"Original 6"},
  {start:1967,end:1992,label:"Expansion"},
  {start:1992,end:2025,label:"Modern"}
];
const BOTTOM_EVENTS = [
  {type:"band", start:1938,end:1945,label:"WWII (1938â€“1945)"},
  {type:"line", year:1991,label:"1991: Dissolution of the USSR"},
  {type:"line", year:2008,label:"2008: KHL founded"}
];

/* ---------- Stable colors + fallback ---------- */
const COLOR_BY_COUNTRY = {
  "Canada":"#E63946","United States":"#1D3557","Sweden":"#F1C40F","Finland":"#2ECC71",
  "Russia":"#E74C3C","Czech Republic":"#8E44AD","Slovakia":"#27AE60","Germany":"#2C3E50",
  "Switzerland":"#C0392B","Australia":"#F39C12","United Kingdom":"#2980B9","Ireland":"#2ECC71",
  "Lebanon":"#C0392B","Kazakhstan":"#3498DB","Japan":"#D35400","Croatia":"#8E0000",
  "Jamaica":"#2ECC71","South Korea":"#95A5A6"
};
function hashColor(str){ let h=0; for(let i=0;i<str.length;i++) h=(h*31+str.charCodeAt(i))|0; const hue=Math.abs(h)%360; return `hsl(${hue},65%,52%)`; }
function colorScale(keys){ const map=new Map(); keys.forEach(k=>map.set(k, COLOR_BY_COUNTRY[k]||hashColor(k))); return k=>map.get(k); }

/* ---------- Flags with robust aliases ---------- */
function isoToFlagEmoji(name){
  if(!name) return "ðŸ’";
  const n=String(name).trim().toLowerCase();
  const map={
    "canada":"CA","united states":"US","usa":"US","u.s.":"US","u.s.a.":"US",
    "sweden":"SE","finland":"FI","russia":"RU","czech republic":"CZ","czechia":"CZ","slovakia":"SK",
    "germany":"DE","switzerland":"CH","latvia":"LV","denmark":"DK","norway":"NO","austria":"AT","france":"FR",
    "netherlands":"NL","slovenia":"SI","belarus":"BY","ukraine":"UA","lithuania":"LT","estonia":"EE","poland":"PL","hungary":"HU","italy":"IT","spain":"ES",
    "united kingdom":"GB","uk":"GB","great britain":"GB","england":"GB","scotland":"GB","wales":"GB",
    "ireland":"IE","republic of ireland":"IE","eire":"IE",
    "australia":"AU","lebanon":"LB","kazakhstan":"KZ","japan":"JP","croatia":"HR","jamaica":"JM",
    "south korea":"KR","republic of korea":"KR","korea, south":"KR","korea (south)":"KR",
    "soviet union":"RU","ussr":"RU","czechoslovakia":"CZ/SK","west germany":"DE","east germany":"DE","serbia and montenegro":"RS","serbia":"RS","montenegro":"ME","yugoslavia":"RS"
  };
  if(map[n]==="CZ/SK") return "ðŸ‡¨ðŸ‡¿ðŸ‡¸ðŸ‡°";
  const iso2=map[n]; if(!iso2||iso2.length!==2) return "ðŸ’";
  const A=0x1F1E6; return String.fromCodePoint(...[...iso2].map(c=>A+c.charCodeAt(0)-65));
}

/* ---------- CSV utils ---------- */
const DASH="[-â€“â€”âˆ’]";
function parseSeasonToYear(value){
  if(value==null) return NaN;
  const s=String(value).trim();
  if(/^\d{4}$/.test(s)) return +s;
  const re=new RegExp(`^(\\d{4})\\s*${DASH}\\s*(\\d{2}|\\d{4})$`);
  const m=s.match(re);
  if(m){ const start=+m[1], part=m[2]; return part.length===2 ? (Math.floor(start/100)*100 + +part) : +part; }
  const m2=s.match(/(\d{4})/); return m2 ? +m2[1] : NaN;
}
function cleanNumber(x){ if(x==null) return 0; const s=String(x).replace(/[,%\s]/g,'').trim(); const n=parseFloat(s); return isNaN(n)?0:n; }
function isSeasonCol(name){ const s=String(name||"").trim(); const re=new RegExp(`^\\d{4}\\s*${DASH}\\s*(?:\\d{2}|\\d{4})$`); return re.test(s); }
function detectWide(text){
  const rows=d3.csvParse(text), cols=rows.columns;
  const seasonCols=cols.filter(isSeasonCol), nonSeasonCols=cols.filter(c=>!isSeasonCol(c));
  if(seasonCols.length>=1) return {wide:true, rows, cols, seasonCols, nonSeasonCols};
  if(rows.length){
    const first=rows[0]; let count=0; cols.forEach(c=>{ if(c && cleanNumber(first[c])>0) count++; });
    if(count>=5) return {wide:true, rows, cols, seasonCols:cols.slice(1), nonSeasonCols:[cols[0]]};
  }
  return {wide:false, rows, cols, seasonCols, nonSeasonCols};
}
function meltWide(rows, seasonCols, countryCol){
  const out=[]; rows.forEach(r=>{ const c=(r[countryCol]||"").toString().trim(); if(!c) return;
    seasonCols.forEach(sc=>{ const v=cleanNumber(r[sc]); if(!isNaN(v)) out.push({year:parseSeasonToYear(sc), country:c, percent:v}); });
  }); return out;
}
function parseCSV(text){
  const {wide, rows, cols, seasonCols, nonSeasonCols}=detectWide(text);
  if(wide){ const countryCol=nonSeasonCols[0]||cols[0]; return {format:'wide', rows:meltWide(rows, seasonCols.length?seasonCols:cols.slice(1), countryCol)}; }
  const raw=d3.csvParse(text);
  const long=raw.map(r=>{
    const yearRaw=r.year??r.Year??r.season??r.Season??r.SEASON??r.SeasonYear;
    const countryRaw=r.country??r.Country??r.nationality??r.Nationality??r.NATION??r.Nation;
    const gamesRaw=r.games??r.Games??r.GP??r.Count??r.count??r.GamesPlayed??r.GAMES;
    const percentRaw=r.percent??r.Percent??r.share??r.Share;
    const y=parseSeasonToYear(yearRaw), c=(countryRaw||"").toString().trim();
    const out={year:y, country:c};
    if(percentRaw!=null && percentRaw!=='') out.percent=cleanNumber(percentRaw);
    if(gamesRaw!=null && gamesRaw!=='') out.games=cleanNumber(gamesRaw);
    return out;
  });
  return {format:'long', rows:long};
}
function toStackData(parsed){
  let rows=parsed.rows.filter(r=>r.country && Number.isFinite(r.year));
  const hasPct=rows.some(r=>typeof r.percent==='number' && r.percent>0);
  if(!hasPct){
    const totals=d3.rollup(rows, v=>d3.sum(v,d=>cleanNumber(d.games||0)), d=>d.year);
    rows=rows.map(r=>{ const t=totals.get(r.year)||0; const pct=t>0? (100*cleanNumber(r.games||0)/t):0; return {year:r.year, country:r.country, percent:pct}; });
  }
  const years=Array.from(new Set(rows.map(r=>r.year))).filter(Number.isFinite).sort((a,b)=>a-b);
  const countries=Array.from(new Set(rows.map(r=>r.country))).filter(Boolean);
  const data=years.map(y=>{
    const row={year:y}; const byC=new Map();
    rows.filter(r=>r.year===y).forEach(r=>byC.set(r.country, r.percent));
    const total=Array.from(byC.values()).reduce((a,b)=>a+b,0)||1;
    countries.forEach(c=>row[c]=(byC.get(c)||0)/total);
    return row;
  });
  return {data, years, countries};
}
async function fetchFirst(paths){ for(const p of paths){ try{ const txt=await fetch(p,{cache:'no-store'}).then(r=>{ if(!r.ok) throw new Error(r.statusText); return r.text(); }); return txt; }catch(e){} } throw new Error("CSV fetch failed."); }
async function loadText(){ const candidates=["2025_NHL_Nationality.csv","2025%20NHL%20Nationality.csv","nhl_nationality_games.csv"]; return await fetchFirst(candidates); }

/* ---------- Render ---------- */
(async function init(){
  let text; try{ text=await loadText(); }catch{ document.getElementById('chart').innerHTML='<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#aab3c2;text-align:center;padding:16px;">Could not load a CSV. Serve the folder via a local web server.</div>'; return; }
  const parsed=parseCSV(text);
  const {data, years, countries}=toStackData(parsed);
  if(!data.length){ document.getElementById('chart').innerHTML='<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#aab3c2;text-align:center;padding:16px;">No plottable data.</div>'; return; }

  const container=d3.select('#chart');
  const W=container.node().clientWidth;
  const H=container.node().clientHeight;
  const isMobile = W <= 720;

  const topCalloutH=26, xAxisRoom=28, bottomCalloutH=46;
  const margin={ top:28+topCalloutH, right:isMobile?24:110, bottom:34 + xAxisRoom + bottomCalloutH, left:44 };
  const innerW=W-margin.left-margin.right, innerH=H-margin.top-margin.bottom;

  const svg=container.append('svg').attr('width',W).attr('height',H);
  const g=svg.append('g').attr('transform',`translate(${margin.left},${margin.top})`);

  const x=d3.scaleLinear().domain(d3.extent(years)).range([0,innerW]);
  const y=d3.scaleLinear().domain([0,1]).range([innerH,0]);

  const yAxis=d3.axisLeft(y).tickValues(d3.range(0,1.0001,0.1)).tickFormat(d=>d3.format('.0%')(d));
  const xAxis=d3.axisBottom(x).ticks(Math.min(14,years.length)).tickFormat(d3.format('d'));
  g.append('g').attr('class','axis').call(yAxis);
  g.append('g').attr('class','axis').attr('transform',`translate(0,${innerH})`).call(xAxis);

  // Stack
  const color=colorScale(countries);
  const stack=d3.stack().keys(countries).order(d3.stackOrderNone).offset(d3.stackOffsetExpand);
  const series=stack(data);
  const area=d3.area().x(d=>x(d.data.year)).y0(d=>y(d[0])).y1(d=>y(d[1])).curve(d3.curveMonotoneX);
  g.append('g').attr('class','areas').selectAll('path.area')
    .data(series,d=>d.key).join('path')
    .attr('class','area')
    .attr('fill',d=>color(d.key))
    .attr('d',d=>area(d));

  // Grid on TOP
  const gridTop=g.append('g').attr('class','grid-top').attr('pointer-events','none');
  d3.range(0,1.0001,0.1).forEach(v=>{ gridTop.append('line').attr('x1',0).attr('x2',innerW).attr('y1',y(v)).attr('y2',y(v)); });

  // TOP era callouts (short on mobile; tap/click to toggle full)
  let showShort = isMobile;
  const ERA_BANDS = () => (showShort ? ERA_BANDS_SHORT : ERA_BANDS_FULL);
  const eraG=g.append('g').attr('class','era-callouts');
  function drawEras(){
    eraG.selectAll('*').remove();
    ERA_BANDS().forEach(({start,end,label})=>{
      const x1=x(start), x2=x(end);
      eraG.append('rect').attr('class','era-band')
        .attr('x',Math.min(x1,x2)).attr('y',-topCalloutH+2)
        .attr('width',Math.abs(x2-x1)).attr('height',topCalloutH-4)
        .attr('rx',4);
      eraG.append('text').attr('class','era-label')
        .attr('x',(x1+x2)/2).attr('y',-topCalloutH/2+4)
        .attr('text-anchor','middle').attr('dominant-baseline','middle')
        .text(label);
    });
  }
  drawEras();
  eraG.on('click', ()=>{ showShort=!showShort; drawEras(); });

  // Bottom events (below x-axis labels)
  const eventsG=g.append('g').attr('class','bottom-events');
  const eventsYTop=innerH + xAxisRoom + 6;
  const bandH=bottomCalloutH - 12;
  const ww=BOTTOM_EVENTS.find(e=>e.type==="band");
  if(ww){
    const x1=x(ww.start), x2=x(ww.end);
    eventsG.append('rect').attr('class','event-band')
      .attr('x',Math.min(x1,x2)).attr('y',eventsYTop)
      .attr('width',Math.abs(x2-x1)).attr('height',bandH).attr('rx',3);
    eventsG.append('text').attr('class','event-label')
      .attr('x',(x1+x2)/2).attr('y',eventsYTop+bandH/2+2)
      .attr('text-anchor','middle').attr('dominant-baseline','middle')
      .text(ww.label);
  }
  BOTTOM_EVENTS.filter(e=>e.type==="line").forEach((e,i)=>{
    const xx=x(e.year), y1=eventsYTop+6, y2=eventsYTop+bandH-6;
    eventsG.append('line').attr('class','event-line').attr('x1',xx).attr('x2',xx).attr('y1',y1).attr('y2',y2);
    const labelY=eventsYTop + bandH/2 + (i ? (i%2===0 ? -12 : 12) : -12);
    eventsG.append('text').attr('class','event-label').attr('x',xx+6).attr('y',labelY).attr('dominant-baseline','middle').text(e.label);
  });

  // Lockout (centered label)
  const lockX=x(LOCKOUT_YEAR);
  const lockG=g.append('g').attr('class','lockout-overlay');
  lockG.append('rect').attr('class','lockout-bar').attr('x',lockX-6).attr('y',0).attr('width',12).attr('height',innerH);
  lockG.append('text').attr('class','lockout-text')
    .attr('transform',`translate(${lockX+5}, ${innerH/2}) rotate(-90)`)
    .attr('text-anchor','middle').text('lockout');

  // Hover marker + tooltip
  const marker=g.append('g').attr('class','year-marker').style('display','none');
  marker.append('line').attr('y1',0).attr('y2',innerH);
  const badge=marker.append('g');
  badge.append('rect').attr('class','year-badge').attr('rx',6).attr('ry',6).attr('width',44).attr('height',18);
  badge.append('text').attr('class','year-text').attr('x',22).attr('y',12).attr('text-anchor','middle');
  const tooltip=d3.select('#chart').append('div').attr('class','tooltip');

  // Legend
  const legend=d3.select('#legend');
  const items=legend.selectAll('.item').data(countries).join('div')
    .attr('class','item').attr('data-key',d=>d)
    .on('click', function(e,key){ activeKey = (activeKey===key? null : key); updateHighlight(); });
  items.append('span').attr('class','flag').text(d=>isoToFlagEmoji(d));
  items.append('span').attr('class','name').text(d=>d);
  items.append('span').attr('class','val').text('â€”');

  function updateLegendValues(idx){
    if(idx==null) idx=data.length-1;
    const row=data[idx];
    items.select('.val').text(d=>{ const v=(row[d]||0)*100; return v? v.toFixed(1)+'%' : '0.0%'; });
  }

  // Top-5 labels at right edge (skip on mobile)
  if(!isMobile){
    const lastRow=data[data.length-1];
    const shares=countries.map(c=>({c,s:lastRow[c]||0})).sort((a,b)=>d3.descending(a.s,b.s)).slice(0,5);
    const idxLast=data.length-1;
    shares.forEach(({c})=>{
      const seg=series.find(s=>s.key===c)[idxLast];
      const mid=(seg[0]+seg[1])/2, yMid=y(mid);
      const xText=innerW+6;
      g.append('text').attr('class','toplabel').attr('x',xText).attr('y',yMid+4).text(c).classed('hide-mobile', true);
    });
  }

  // Interaction
  const overlay=g.append('rect').attr('fill','transparent').attr('pointer-events','all')
    .attr('x',0).attr('y',0).attr('width',innerW).attr('height',innerH);
  const bisect=d3.bisector(d=>d.year).center;
  let activeKey=null;

  function updateHighlight(){
    d3.selectAll('.areas .area').classed('dim', d => activeKey && d.key !== activeKey);
    d3.selectAll('.legend .item').classed('active', function(){ return d3.select(this).attr('data-key') === activeKey; });
  }
  function findCountryAt(xp,yp){
    const xm=x.invert(xp), idx=Math.max(0,Math.min(data.length-1,bisect(data,xm)));
    const yNorm=y.invert(yp);
    for(const s of series){ const seg=s[idx]; if(yNorm>=seg[0] && yNorm<=seg[1]) return {key:s.key, idx, seg}; }
    return {key:null, idx, seg:null};
  }
  function moveToYear(targetYear){
    const idx=Math.max(0,Math.min(data.length-1,d3.bisector(d=>d).center(years,+targetYear)));
    const year=years[idx];
    marker.style('display',null);
    marker.attr('transform',`translate(${x(year)},0)`);
    badge.attr('transform',`translate(${Math.min(innerW-44, Math.max(0, x(year)-22))}, -22)`);
    badge.select('text').text(year);
    updateLegendValues(idx);
  }

  overlay.on('mousemove',(evt)=>{
    const [mx,my]=d3.pointer(evt,g.node());
    const {key,idx,seg}=findCountryAt(mx,my);
    marker.style('display',null);
    const year=data[idx].year;
    marker.attr('transform',`translate(${x(year)},0)`);
    badge.attr('transform',`translate(${Math.min(innerW-44, Math.max(0, x(year)-22))}, -22)`);
    badge.select('text').text(year);
    updateLegendValues(idx);
    let html=`<strong>${year}</strong>`;
    if(key){ const pct=((seg[1]-seg[0])*100).toFixed(1); html+=`<br>${key}: ${pct}%`; }
    tooltip.style('opacity',1).html(html).style('left',(evt.offsetX+14)+'px').style('top',(evt.offsetY-28)+'px');
  }).on('mouseleave',()=>{
    tooltip.style('opacity',0); marker.style('display','none'); updateLegendValues(null);
  });

  const yearInput=document.getElementById('yearSearch');
  yearInput.min=years[0]; yearInput.max=years[years.length-1]; yearInput.step=1;
  yearInput.addEventListener('change',()=>{ const v=+yearInput.value; if(Number.isFinite(v)) moveToYear(v); });
  yearInput.addEventListener('keydown',e=>{ if(e.key==='Enter'){ const v=+yearInput.value; if(Number.isFinite(v)) moveToYear(v); } });

  // Initialize legend with latest year
  updateLegendValues(null);
})();
</script>
</body>
</html>
