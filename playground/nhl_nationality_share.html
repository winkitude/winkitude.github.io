<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NHL Nationality Share â€“ Interactive Stacked Area Chart</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root { --bg:#0b0e13; --panel:#121622; --ink:#e8ecf1; --muted:#aab3c2; --accent:#6aa6ff; --grid:#2a3245; --gridBright:#3b4661; }
    html, body { height:100%; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:var(--bg); color:var(--ink); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    .wrap { max-width:1100px; margin: 32px auto 48px; padding: 0 16px; }
    h1 { font-size:24px; margin:0 0 4px; letter-spacing:.2px; }
    .sub { color:var(--muted); margin-bottom:16px; font-size:14px; }
    .chart-card { background:var(--panel); border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.3); padding:16px 16px 8px; }

    .controls { display:flex; gap:10px; align-items:center; margin: 0 0 10px; }
    .controls label { font-size:12px; color:var(--muted); }
    .controls input { border:1px solid rgba(255,255,255,.12); background:#0e1526; color:var(--ink); padding:6px 8px; border-radius:10px; outline:none; font-size:13px; width:120px; }
    .controls input::placeholder { color:#7f8aa6; }

    .chart { width:100%; height:560px; position:relative; }
    .axis path, .axis line { stroke: var(--grid); }
    .axis text { fill: var(--muted); font-size: 12px; }
    .areas .area { opacity:.95; transition: opacity .15s ease, filter .15s; }
    .areas .area.dim { opacity:.18; filter: grayscale(30%); }

    .legend { display:grid; grid-template-columns: repeat(auto-fill, minmax(200px,1fr)); gap: 8px 10px; margin-top:14px; }
    .legend .item { display:flex; align-items:center; gap:10px; padding:8px 12px; border-radius:12px; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.08); cursor:pointer; user-select:none; }
    .legend .item.active { outline:2px solid var(--accent); background: rgba(106,166,255,.12); }
    .legend .flag { font-size:18px; line-height:1; }
    .legend .name { color:var(--ink); font-size:13px; flex: 1 1 auto; }
    .legend .val { color:var(--muted); font-variant-numeric: tabular-nums; font-size:12px; }

    .tooltip { position:absolute; pointer-events:none; z-index:10; background:#0d1220; color:var(--ink); border:1px solid rgba(255,255,255,.1); padding:8px 10px; border-radius:10px; font-size:12px; box-shadow:0 6px 18px rgba(0,0,0,.35); opacity:0; transition:opacity .1s; }
    .note { color:var(--muted); font-size:12px; margin-top:8px; }
    .debug { color:#c9d1d9; background:#0e1625; border:1px solid #24314a; border-radius:10px; padding:8px 10px; font-size:12px; margin-top:10px; white-space:pre-wrap; }

    .year-marker line { stroke: var(--gridBright); stroke-width: 1.25; }
    .year-badge { fill: #0d1220; stroke: rgba(255,255,255,.15); stroke-width:1; }
    .year-text { fill: var(--ink); font-size: 11px; }
    .grid-top line { stroke: var(--gridBright); stroke-dasharray: 2 3; }

    /* Lockout bar on top (2005 only) */
    .lockout-bar { fill: #000; }
    .lockout-text { fill: #fff; font-weight: 700; font-size: 10px; letter-spacing: .6px; }

    .toplabel { fill: var(--ink); font-size: 12px; paint-order: stroke; stroke: rgba(0,0,0,.35); stroke-width: 2px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>NHL Games by Player Nationality (Share by Year)</h1>
    <div class="sub">100% stacked by year. Hover anywhere to see values; click a country below to spotlight it. 2005 lockout marked.</div>
    <div class="chart-card">
      <div class="controls">
        <label for="yearSearch">Go to year:</label>
        <input id="yearSearch" type="number" placeholder="e.g. 2005" />
      </div>

      <div id="chart" class="chart"></div>
      <div id="legend" class="legend" aria-label="Countries"></div>
      <div class="note">
        The page will try to load one of these CSVs from the same folder: <code>2025_NHL_Nationality.csv</code>, <code>2025 NHL Nationality.csv</code>, or <code>nhl_nationality_games.csv</code>.
      </div>
      <div id="debug" class="debug" style="display:none"></div>
    </div>
  </div>

  <script>
  // =================== Config & helpers ===================
  const LOCKOUT_YEAR = 2005; // only 2005
  const PALETTE = ["#5B8FF9","#5AD8A6","#5D7092","#F6BD16","#6F5EF9","#6DC8EC","#945FB9","#FF9845","#1E9493","#FF99C3","#FF6B6B","#41C1B2","#B28DFF","#78D3F8","#FFD166","#EF476F","#06D6A0","#118AB2","#8338EC","#3A86FF"];
  const DASH = "[-â€“â€”âˆ’]"; // hyphen, en dash, em dash, minus
  const debugEl = document.getElementById('debug');
  const log = (txt) => { debugEl.style.display='block'; debugEl.textContent = txt; console.log(txt); };

  function isoToFlagEmoji(name){
    const map = {
      "Canada":"CA","United States":"US","USA":"US",
      "Sweden":"SE","Russia":"RU","Soviet Union":"RU","Czech Republic":"CZ","Czechia":"CZ","Finland":"FI",
      "Germany":"DE","Slovakia":"SK","Switzerland":"CH","Latvia":"LV","Denmark":"DK","Norway":"NO","Austria":"AT",
      "France":"FR","United Kingdom":"GB","England":"GB","Scotland":"GB","Wales":"GB","Slovenia":"SI","Netherlands":"NL",
      "Belarus":"BY","Ukraine":"UA","Lithuania":"LT","Estonia":"EE","Poland":"PL","Hungary":"HU","Italy":"IT","Spain":"ES"
    };
    const iso2 = map[name] || "";
    if (!iso2 || iso2.length !== 2) return "ðŸ’";
    const A=0x1F1E6;
    return String.fromCodePoint(...[...iso2].map(c=>A+c.charCodeAt(0)-65));
  }

  function parseSeasonToYear(value){
    if (value == null) return NaN;
    const s = String(value).trim();
    if (/^\d{4}$/.test(s)) return +s;
    const re = new RegExp(`^(\\d{4})\\s*${DASH}\\s*(\\d{2}|\\d{4})$`);
    const m = s.match(re);
    if (m){
      const start = +m[1];
      const endPart = m[2];
      const endYear = endPart.length === 2 ? (Math.floor(start/100)*100 + +endPart) : +endPart;
      return endYear;
    }
    const m2 = s.match(/(\d{4})/);
    return m2 ? +m2[1] : NaN;
  }

  function cleanNumber(x){
    if (x == null) return 0;
    const s = String(x).replace(/[,%\s]/g,'').trim();
    const n = parseFloat(s);
    return isNaN(n) ? 0 : n;
  }

  function isSeasonCol(name){
    const s = String(name||"").trim();
    const re = new RegExp(`^\\d{4}\\s*${DASH}\\s*(?:\\d{2}|\\d{4})$`);
    return re.test(s);
  }

  function detectWide(text){
    const rows = d3.csvParse(text);
    const cols = rows.columns;
    const seasonCols = cols.filter(isSeasonCol);
    const nonSeasonCols = cols.filter(c => !isSeasonCol(c));
    if (seasonCols.length >= 1) return {wide:true, rows, cols, seasonCols, nonSeasonCols};
    // heuristic: if first row has many numeric-looking cells, treat as wide
    if (rows.length){
      const first = rows[0];
      let numericCount = 0;
      cols.forEach(c => { if (c && cleanNumber(first[c]) > 0) numericCount++; });
      if (numericCount >= 5) return {wide:true, rows, cols, seasonCols: cols.slice(1), nonSeasonCols:[cols[0]]};
    }
    return {wide:false, rows, cols, seasonCols, nonSeasonCols};
  }

  function meltWide(rows, seasonCols, countryCol){
    const out = [];
    rows.forEach(r => {
      const country = (r[countryCol]||"").toString().trim();
      if (!country) return;
      seasonCols.forEach(sc => {
        const val = cleanNumber(r[sc]);
        if (!isNaN(val)) {
          const year = parseSeasonToYear(sc);
          out.push({year, country, percent: val});
        }
      });
    });
    return out;
  }

  function parseCSV(text){
    const {wide, rows, cols, seasonCols, nonSeasonCols} = detectWide(text);
    if (wide){
      const countryCol = nonSeasonCols[0] || cols[0];
      const long = meltWide(rows, seasonCols.length?seasonCols:cols.slice(1), countryCol);
      return {format:'wide', rows: long};
    } else {
      const raw = d3.csvParse(text);
      const long = raw.map(r => {
        const yearRaw = r.year ?? r.Year ?? r.season ?? r.Season ?? r.SEASON ?? r.SeasonYear;
        const countryRaw = r.country ?? r.Country ?? r.nationality ?? r.Nationality ?? r.NATION ?? r.Nation;
        const gamesRaw = r.games ?? r.Games ?? r.GP ?? r.Count ?? r.count ?? r.GamesPlayed ?? r.GAMES;
        const percentRaw = r.percent ?? r.Percent ?? r.share ?? r.Share;
        const y = parseSeasonToYear(yearRaw);
        const c = (countryRaw||"").toString().trim();
        const out = { year: y, country: c };
        if (percentRaw != null && percentRaw !== '') out.percent = cleanNumber(percentRaw);
        if (gamesRaw != null && gamesRaw !== '') out.games = cleanNumber(gamesRaw);
        return out;
      });
      return {format:'long', rows: long};
    }
  }

  function toStackData(parsed){
    let rows = parsed.rows.filter(r => r.country && Number.isFinite(r.year));
    let usePercent = rows.some(r => typeof r.percent === 'number' && r.percent > 0);
    if (!usePercent){
      const byYear = d3.rollup(rows, v => d3.sum(v, d=>cleanNumber(d.games||0)), d=>d.year);
      rows = rows.map(r => {
        const total = byYear.get(r.year)||0;
        const pct = total>0 ? (100 * cleanNumber(r.games||0) / total) : 0;
        return { year: r.year, country: r.country, percent: pct };
      });
    }
    const years = Array.from(new Set(rows.map(r => r.year))).filter(y => Number.isFinite(y)).sort((a,b)=>a-b);
    const countries = Array.from(new Set(rows.map(r => r.country))).filter(Boolean);

    const data = years.map(y => {
      const row = {year:y};
      const byC = new Map();
      rows.filter(r=>r.year===y).forEach(r => byC.set(r.country, r.percent));
      const totalPct = Array.from(byC.values()).reduce((a,b)=>a+b,0) || 1;
      countries.forEach(c => { row[c] = (byC.get(c)||0) / totalPct; }); // 0..1
      return row;
    });
    return {data, years, countries};
  }

  async function fetchFirst(paths){
    for(const p of paths){
      try{
        const txt = await fetch(p, {cache:'no-store'}).then(r=>{ if(!r.ok) throw new Error(r.statusText); return r.text(); });
        return txt;
      }catch(e){}
    }
    throw new Error("All CSV fetch attempts failed: "+paths.join(", "));
  }

  async function loadText(){
    const candidates = ["2025_NHL_Nationality.csv","2025%20NHL%20Nationality.csv","nhl_nationality_games.csv"];
    return await fetchFirst(candidates);
  }

  function colorScale(keys){ const map=new Map(); keys.forEach((k,i)=>map.set(k,PALETTE[i%PALETTE.length])); return k=>map.get(k); }

  // =================== Render ===================
  async function init(){
    let text;
    try { text = await loadText(); }
    catch (e) {
      log("CSV fetch failed: " + e.message);
      document.getElementById('chart').innerHTML = '<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#aab3c2;text-align:center;padding:16px;">Could not load a CSV. Make sure the HTML and CSV are in the same folder and you are serving them from a local web server.</div>';
      return;
    }
    const parsed = parseCSV(text);
    log(`Detected format: ${parsed.format}. Parsed rows: ${parsed.rows.length}`);

    const {data, years, countries} = toStackData(parsed);
    if (!data.length || !years.length || !countries.length){
      document.getElementById('chart').innerHTML = '<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#aab3c2;text-align:center;padding:16px;">No plottable data after transform.</div>';
      return;
    }

    // Year search
    const yearInput = document.getElementById('yearSearch');
    yearInput.min = years[0];
    yearInput.max = years[years.length-1];
    yearInput.step = 1;

    const color = colorScale(countries);
    const container=d3.select('#chart');
    const W=container.node().clientWidth;
    const H=container.node().clientHeight;
    const margin={top:28,right:100,bottom:34,left:44};
    const innerW=W-margin.left-margin.right;
    const innerH=H-margin.top-margin.bottom;

    const svg=container.append('svg').attr('width',W).attr('height',H);
    const g=svg.append('g').attr('transform',`translate(${margin.left},${margin.top})`);

    const x=d3.scaleLinear().domain(d3.extent(years)).range([0,innerW]);
    const y=d3.scaleLinear().domain([0,1]).range([innerH,0]);

    const yAxis=d3.axisLeft(y).tickValues(d3.range(0,1.0001,0.1)).tickFormat(d=>d3.format('.0%')(d));
    const xAxis=d3.axisBottom(x).ticks(Math.min(14,years.length)).tickFormat(d3.format('d'));
    g.append('g').attr('class','axis').call(yAxis);
    g.append('g').attr('class','axis').attr('transform',`translate(0,${innerH})`).call(xAxis);

    const stack=d3.stack().keys(countries).order(d3.stackOrderNone).offset(d3.stackOffsetExpand);
    const series=stack(data);
    const area=d3.area().x(d=>x(d.data.year)).y0(d=>y(d[0])).y1(d=>y(d[1])).curve(d3.curveMonotoneX);
    g.append('g').attr('class','areas').selectAll('path.area')
      .data(series,d=>d.key).join('path')
      .attr('class','area')
      .attr('fill',d=>color(d.key))
      .attr('d',d=>area(d));

    // Grid on TOP
    const gridTop = g.append('g').attr('class','grid-top').attr('pointer-events','none');
    d3.range(0,1.0001,0.1).forEach(v => {
      gridTop.append('line').attr('x1',0).attr('x2',innerW).attr('y1',y(v)).attr('y2',y(v));
    });

    // Lockout bar ON TOP: black bar with vertical "lockout" text at 2005
    const lockX = x(LOCKOUT_YEAR);
    const lockGroup = g.append('g').attr('class','lockout-overlay');
    lockGroup.append('rect').attr('class','lockout-bar')
      .attr('x', lockX-6).attr('y', 0).attr('width', 12).attr('height', innerH);
    // vertical text (rotated -90 so it reads down the bar)
    lockGroup.append('text').attr('class','lockout-text')
      .attr('transform', `translate(${lockX+5}, 10) rotate(-90)`)
      .text('lockout');

    // Always-on hover marker
    const marker = g.append('g').attr('class','year-marker').style('display','none');
    marker.append('line').attr('y1',0).attr('y2',innerH);
    const badge = marker.append('g');
    badge.append('rect').attr('class','year-badge').attr('rx',6).attr('ry',6).attr('width',44).attr('height',18);
    badge.append('text').attr('class','year-text').attr('x',22).attr('y',12).attr('text-anchor','middle');

    const tooltip=d3.select('#chart').append('div').attr('class','tooltip');

    // Legend (full names + values)
    const legend = d3.select('#legend');
    const items = legend.selectAll('.item').data(countries).join('div')
      .attr('class','item')
      .attr('data-key',d=>d)
      .on('click', function(e, key){
        activeKey = (activeKey === key ? null : key);
        updateHighlight();
      });
    items.append('span').attr('class','flag').text(d=>isoToFlagEmoji(d));
    items.append('span').attr('class','name').text(d=>d);
    items.append('span').attr('class','val').text('â€”');

    function updateLegendValues(idx){
      if (idx == null) idx = data.length - 1;
      const row = data[idx];
      items.select('.val').text(d => {
        const v = (row[d] || 0) * 100;
        return v ? v.toFixed(1) + '%' : '0.0%';
      });
    }

    // Top 5 labels at right edge (latest year)
    const lastRow = data[data.length-1];
    const shares = countries.map(c => ({c, s: lastRow[c] || 0}))
                            .sort((a,b)=>d3.descending(a.s,b.s)).slice(0,5);
    const idxLast = data.length-1;
    shares.forEach(({c}) => {
      const seg = series.find(s=>s.key===c)[idxLast];
      const mid = (seg[0]+seg[1])/2;
      const yMid = y(mid);
      const xText = innerW + 6;
      g.append('text').attr('class','toplabel').attr('x', xText).attr('y', yMid+4).text(c);
    });

    const overlay = g.append('rect').attr('fill','transparent').attr('pointer-events','all')
      .attr('x',0).attr('y',0).attr('width',innerW).attr('height',innerH);

    const bisect = d3.bisector(d=>d.year).center;
    let activeKey = null;

    function updateHighlight(){
      d3.selectAll('.areas .area')
        .classed('dim', d => activeKey && d.key !== activeKey);
      d3.selectAll('.legend .item')
        .classed('active', function(){ return d3.select(this).attr('data-key') === activeKey; });
    }

    function findCountryAt(xp, yp){
      const xm = x.invert(xp);
      const idx = Math.max(0, Math.min(data.length - 1, bisect(data, xm)));
      const yNorm = y.invert(yp);
      for (const s of series){
        const seg = s[idx];
        if (yNorm >= seg[0] && yNorm <= seg[1]) return {key: s.key, idx, seg};
      }
      return {key: null, idx, seg: null};
    }

    function moveToYear(targetYear){
      const idx = Math.max(0, Math.min(data.length - 1, d3.bisector(d=>d).center(years, +targetYear)));
      const year = years[idx];
      marker.style('display', null);
      marker.attr('transform', `translate(${x(year)},0)`);
      badge.attr('transform', `translate(${Math.min(innerW-44, Math.max(0, x(year)-22))}, -22)`);
      badge.select('text').text(year);
      updateLegendValues(idx);
    }

    overlay.on('mousemove', (evt) => {
      const [mx, my] = d3.pointer(evt, g.node());
      const {key, idx, seg} = findCountryAt(mx, my);

      marker.style('display', null);
      const year = data[idx].year;
      marker.attr('transform', `translate(${x(year)},0)`);
      badge.attr('transform', `translate(${Math.min(innerW-44, Math.max(0, x(year)-22))}, -22)`);
      badge.select('text').text(year);

      updateLegendValues(idx);

      let html = `<strong>${year}</strong>`;
      if (key){
        const pct = ((seg[1]-seg[0])*100).toFixed(1);
        html += `<br>${key}: ${pct}%`;
      }
      tooltip.style('opacity',1).html(html)
        .style('left',(evt.offsetX + 14) + 'px')
        .style('top',(evt.offsetY - 28) + 'px');
    }).on('mouseleave', () => {
      tooltip.style('opacity',0);
      marker.style('display','none');
      updateLegendValues(null);
    });

    // Year search interactions
    yearInput.addEventListener('change', () => {
      const val = +yearInput.value;
      if (Number.isFinite(val)) moveToYear(val);
    });
    yearInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter'){
        const val = +yearInput.value;
        if (Number.isFinite(val)) moveToYear(val);
      }
    });

    // Initialize legend with latest year
    updateLegendValues(null);
  }

  init();
  </script>
</body>
</html>
