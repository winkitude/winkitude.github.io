<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simpsons Relationship Network — Interactive</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .app { display: grid; grid-template-columns: 280px 1fr; grid-template-rows: auto 1fr; height: 100%; }
    header { grid-column: 1 / -1; display: flex; align-items: center; gap: 12px; padding: 10px 14px; border-bottom: 1px solid #eee; position: sticky; top: 0; background: #fff; z-index: 2; }
    header .title { font-weight: 600; }
    aside { border-right: 1px solid #eee; padding: 14px; overflow: auto; }
    main { position: relative; overflow: hidden; background: #fff; }
    .section { margin-bottom: 14px; }
    .section h3 { margin: 0 0 8px; font-size: 14px; font-weight: 600; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 8px 0; }
    .legend { display: flex; flex-direction: column; gap: 6px; }
.legend-row { display: flex; align-items: center; gap: 8px; }
.chip { width: 14px; height: 14px; border-radius: 3px; flex: 0 0 14px; }
.legend-row input[type="checkbox"] { margin: 0; }
    .chip { width: 14px; height: 14px; border-radius: 3px; }
    .small { font-size: 12px; color: #5a5a5a; }
    .toolbar button { padding: 6px 10px; border: 1px solid #ddd; background: #fff; border-radius: 8px; cursor: pointer; }
    .toolbar button + button { margin-left: 8px; }
    .badge { position: absolute; bottom: 10px; left: 10px; background: rgba(255,255,255,0.92); border: 1px solid #eee; padding: 8px 10px; border-radius: 10px; font-size: 13px; box-shadow: 0 2px 10px rgba(0,0,0,0.06); }
    .controls { display: flex; gap: 8px; align-items: center; }
    input[type="range"] { width: 160px; }
    .hint { color: #777; font-size: 12px; }
  </style>
  <script src="https://unpkg.com/force-graph"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">Simpsons Relationship Network</div>
      <div class="toolbar" style="margin-left:auto;">
        <button id="fitBtn">Fit</button>
        <button id="zinBtn">Zoom +</button>
        <button id="zoutBtn">Zoom −</button>
      </div>
    </header>

    <aside>
      <div class="controls">
          <input id="csvFile" type="file" accept=".csv" />
          <button id="loadSample">Sample</button>
        </div>
      </div>

      <input id="imgMapFile" type="file" accept=".csv" />
        <div class="small" style="margin-top:8px;">Option B: Upload images (filenames should match character names)</div>
        <input id="imgFiles" type="file" accept="image/*" multiple />
      </div>

      <div class="section">
        <h3>Display</h3>
        <div class="row"><label class="small">Node size</label><input id="sizeRange" type="range" min="0.6" max="2" value="1" step="0.1" /></div>
      </div>

      <div class="section">
        <h3>Relationship Types</h3>
        <div id="legend" class="legend small"></div>
      </div>

      <div class="small hint">
        Click a bubble to highlight direct connections. Pan with drag, zoom with wheel or buttons. Episode column is ignored.
      </div>
    </aside>

    <main>
      <div id="graph"></div>
      <div id="badge" class="badge" style="display:none;"></div>
    </main>
  </div>

<script>
(() => {
  const tab20 = [
    "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd",
    "#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf",
    "#393b79","#637939","#8c6d31","#843c39","#7b4173",
    "#6b6ecf","#b5cf6b","#e7ba52","#d6616b","#ce6dbd"
  ];

  const elGraph = document.getElementById('graph');
  const badge = document.getElementById('badge');
    const sizeRange = document.getElementById('sizeRange');
  const legendEl = document.getElementById('legend');

  // Graph instance
  const Graph = ForceGraph()(elGraph)
    .nodeRelSize(4)
    .backgroundColor('#ffffff')
    .zoom(1)
    .linkDirectionalParticles(0)
    .linkCurvature(0.15);

  // Resize handling
  const resize = () => {
    const rect = elGraph.getBoundingClientRect();
    Graph.width(rect.width).height(rect.height);
  };
  const resizeObserver = new ResizeObserver(resize);
  resizeObserver.observe(elGraph);

  // State
  let rawRows = [];
  let graph = { nodes: [], links: [] };
  let filtered = { nodes: [], links: [] };
  let counts = new Map();
  let typeList = [];
  let activeTypes = {}; // type -> bool
  let nodeScale = 1.0;
  let highlightNode = null;
  let highlightNodes = new Set();
  let highlightLinks = new Set();

  // Images
  const imageMap = new Map(); // name -> url
  const imageCache = new Map(); // url -> HTMLImageElement

  function sanitize(text) {
    return (text||'').toLowerCase().replace(/&/g,'and').replace(/[^\w\s-]+/g,'').trim().replace(/\s+/g,'_');
  }

  function preload(url) {
    if (!url || imageCache.has(url)) return;
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => { imageCache.set(url, img); Graph.refresh(); };
    img.onerror = () => { /* ignore */ };
    img.src = url;
  }

  function buildGraph(rows) {
    counts = new Map();
    const nodesMap = new Map();
    const links = [];
    const typeSet = new Set();

    rows.forEach(r => {
      const p = (r.Person||'').trim();
      const l = (r.Lover||'').trim();
      const t = (r.Type||'').trim();
      if (!p || !l) return;
      counts.set(p, (counts.get(p)||0)+1);
      counts.set(l, (counts.get(l)||0)+1);
      if (!nodesMap.has(p)) nodesMap.set(p, { id: p, val: 1 });
      if (!nodesMap.has(l)) nodesMap.set(l, { id: l, val: 1 });
      links.push({ source: p, target: l, type: t });
      if (t) typeSet.add(t);
    });

    // fill node vals
    nodesMap.forEach((n, id) => { n.val = counts.get(id)||1; });

    graph = { nodes: Array.from(nodesMap.values()), links };
    typeList = Array.from(typeSet.values());

    // reset active types (all ON)
    activeTypes = {}; typeList.forEach(t => activeTypes[t] = true);
    renderLegend();
    applyFilters();
  }

  function renderLegend() {
    legendEl.innerHTML = '';
    typeList.forEach((t, i) => {
      const row = document.createElement('div');
      row.className = 'legend-row';
      const chip = document.createElement('div'); chip.className = 'chip'; chip.style.background = tab20[i % tab20.length];
      const box = document.createElement('input'); box.type = 'checkbox'; box.checked = !!activeTypes[t];
      box.addEventListener('change', () => { activeTypes[t] = box.checked; applyFilters(); });
      const text = document.createElement('div'); text.textContent = t; text.className = 'small';
      row.appendChild(chip); row.appendChild(box); row.appendChild(text);
      legendEl.appendChild(row);
    });
  }

  function applyFilters() {
    const pass = (l) => (l.type ? activeTypes[l.type] : true);
    const links = graph.links.filter(pass);
    const keep = new Set();
    links.forEach(l => { keep.add(typeof l.source==='object'? l.source.id:l.source); keep.add(typeof l.target==='object'? l.target.id:l.target); });
    const nodes = graph.nodes.filter(n => keep.has(n.id));
    filtered = { nodes, links };
    highlightNode = null; highlightNodes.clear(); highlightLinks.clear();
    Graph.graphData(filtered);
    setDrawers();
    setTimeout(() => Graph.zoomToFit(600, 50), 30);
  }

  function colorOfType(type) {
    if (!type) return '#999';
    const idx = typeList.indexOf(type);
    return tab20[idx % tab20.length];
  }

  function nodeRadius(n) {
    const base = 3 + Math.pow(n.val||1, 0.9) * 1.4;
    return base * nodeScale;
  }

  function setDrawers() {
    Graph.nodeCanvasObject((node, ctx, scale) => {
      const r = nodeRadius(node);
      // fade non-highlight when active
      if (highlightNodes.size && !highlightNodes.has(node)) ctx.globalAlpha = 0.18; else ctx.globalAlpha = 1;

      // circle background & stroke
      ctx.beginPath(); ctx.arc(node.x, node.y, r, 0, 2*Math.PI);
      ctx.fillStyle = '#fff'; ctx.fill();
      ctx.lineWidth = highlightNodes.has(node) ? 2.2 : 1;
      ctx.strokeStyle = highlightNodes.has(node) ? '#111' : '#333';
      ctx.stroke();

      // image clip (cover)
      const url = imageMap.get(node.id);
      const img = url ? imageCache.get(url) : null;
      if (img) {
        ctx.save();
        ctx.beginPath(); ctx.arc(node.x, node.y, r - 1, 0, 2*Math.PI); ctx.clip();
        const side = Math.min(img.naturalWidth, img.naturalHeight);
        const sx = (img.naturalWidth - side)/2;
        const sy = (img.naturalHeight - side)/2;
        ctx.drawImage(img, sx, sy, side, side, node.x - r, node.y - r, r*2, r*2);
        ctx.restore();
      }

      // label
      if (highlightNode && node.id === highlightNode.id) {
        const fontSize = Math.max(8, 10/scale);
        ctx.font = `${fontSize}px Inter, ui-sans-serif, system-ui`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillStyle = 'rgba(0,0,0,0.9)';
        ctx.fillText(node.id, node.x, node.y + r + 2);
      }
      ctx.globalAlpha = 1;
    });

    Graph.linkWidth(l => highlightLinks.size && !highlightLinks.has(l) ? 1 : 2.2)
         .linkColor(l => {
            const c = colorOfType(l.type);
            if (highlightLinks.size && !highlightLinks.has(l)) return c + '55';
            return c;
          });
  }

  function onNodeClick(node) {
    highlightNode = node;
    highlightNodes = new Set([node]);
    highlightLinks = new Set();
    filtered.links.forEach(l => {
      const s = typeof l.source==='object' ? l.source.id : l.source;
      const t = typeof l.target==='object' ? l.target.id : l.target;
      if (s === node.id || t === node.id) {
        highlightLinks.add(l);
        highlightNodes.add(typeof l.source==='object' ? l.source : filtered.nodes.find(n => n.id === s));
        highlightNodes.add(typeof l.target==='object' ? l.target : filtered.nodes.find(n => n.id === t));
      }
    });
    setDrawers();
    const distance = 80; // closer zoom
    Graph.centerAt(node.x, node.y, 600);
    Graph.zoom(4, 800);
    badge.style.display = 'block';
    badge.innerHTML = `<div><b>${node.id}</b></div><div class="small">Connections: ${highlightLinks.size}</div>`;
  }

  function clearHighlight() {
    highlightNode = null; highlightNodes.clear(); highlightLinks.clear();
    setDrawers();
    badge.style.display = 'none';
  }

  // Wire events
  Graph.onNodeClick(onNodeClick);
  Graph.onBackgroundClick(clearHighlight);

  document.getElementById('fitBtn').onclick = () => Graph.zoomToFit(800, 50);
  document.getElementById('zinBtn').onclick = () => Graph.zoom(Graph.zoom()*1.2, 400);
  document.getElementById('zoutBtn').onclick = () => Graph.zoom(Graph.zoom()/1.2, 400);
  sizeRange.addEventListener('input', e => { nodeScale = parseFloat(e.target.value || '1'); Graph.refresh(); });

  // CSV upload
    // Image map CSV (name,url)
    // Local images (multiple)
    // Sample data for quick demo
  document.getElementById('loadSample').addEventListener('click', () => {
    const sample = `Person,Lover,Type,Episode\nHomer Simpson,Marge Simpson,Married,\nHomer Simpson,Lurleen Lumpkin,Crush,\nMarge Simpson,Artie Ziff,Ex,\nBart Simpson,Jessica Lovejoy,Crush,\nLisa Simpson,Milhouse Van Houten,Crush,\nLisa Simpson,Nelson Muntz,Dated,`;
    Papa.parse(sample, { header: true, skipEmptyLines: true, complete: (res) => {
      rawRows = res.data;
      buildGraph(rawRows);
    }});
  });

  // Initial size
  setTimeout(() => resize(), 0);
})();
</script>
</body>
</html>
